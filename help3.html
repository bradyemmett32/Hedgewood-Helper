<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hedgewood Helper - Channel Magick</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #2a5298;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }

        .character-setup {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .character-setup h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 15px;
            align-items: start;
        }

        .setup-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .setup-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .level-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .level-input {
            width: 60px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .class-option {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .class-option:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .class-option.selected {
            background: rgba(255, 255, 255, 0.9);
            color: #2a5298;
            border-color: white;
            font-weight: bold;
        }

        .class-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .spell-builder {
            display: grid;
            gap: 25px;
            margin-bottom: 30px;
        }

        .section {
            background: linear-gradient(135deg, #f6f8fb 0%, #e9ecf4 100%);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            display: none;
            animation: slideIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .required {
            color: #e74c3c;
        }

        .spell-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .spell-type-card {
            background: white;
            border: 3px solid #ddd;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .spell-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .spell-type-card.selected {
            border-color: #2a5298;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .spell-type-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .spell-type-name {
            font-size: 1.2em;
            font-weight: bold;
        }

        .spell-base-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .spell-option {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .spell-option:hover {
            border-color: #2a5298;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42, 82, 152, 0.2);
        }

        .spell-option.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #764ba2;
        }

        .spell-option-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .spell-option-description {
            font-size: 0.85em;
            opacity: 0.9;
            line-height: 1.3;
        }

        .dice-info {
            display: inline-block;
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            margin-top: 5px;
        }

        .damage-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
        }

        .damage-type-option {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .damage-type-option:hover {
            border-color: #2a5298;
            background: #f0f4ff;
        }

        .damage-type-option.selected {
            background: #2a5298;
            color: white;
            border-color: #1e3c72;
        }

        .damage-type-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .damage-type-option.disabled:hover {
            border-color: #ddd;
            background: #f5f5f5;
            transform: none;
        }

        .damage-type-category {
            font-weight: bold;
            color: #666;
            margin: 15px 0 8px 0;
            font-size: 0.9em;
            text-transform: uppercase;
        }

        .channel-counter {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }

        .channel-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .channel-btn {
            background: white;
            color: #333;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .channel-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.9);
        }

        .channel-display {
            font-size: 2em;
            font-weight: bold;
            min-width: 50px;
        }

        .component-modules {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .component-module {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .component-module:hover {
            border-color: #2a5298;
            background: #f8f9ff;
        }

        .component-module.selected {
            background: #2a5298;
            color: white;
            border-color: #1e3c72;
        }

        .component-module.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .component-module-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .component-module-description {
            font-size: 0.85em;
            line-height: 1.3;
        }

        .spell-output {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            display: none;
        }

        .spell-output.visible {
            display: block;
            animation: slideIn 0.5s ease;
        }

        .spell-name {
            font-size: 2em;
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 15px;
            text-align: center;
        }

        .spell-details {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: bold;
            color: #555;
        }

        .detail-value {
            color: #333;
        }

        .spell-description {
            line-height: 1.6;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #eee;
            font-style: italic;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .save-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .export-btn {
            background: linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .saved-spells {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #ddd;
        }

        .saved-spells h2 {
            color: #2a5298;
            margin-bottom: 20px;
        }

        .spell-card {
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .spell-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            color: #e74c3c;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .delete-btn:hover {
            background: #e74c3c;
            color: white;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .reset-btn {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            margin-left: auto;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚡ Channel Magick Spell Creator ⚡</h1>
        <p class="subtitle">Create custom spells by combining base types with component modules</p>

        <!-- Character Setup Section -->
        <div class="character-setup">
            <h3>📜 Character Setup</h3>
            <div class="setup-grid">
                <div class="setup-section">
                    <div class="setup-label">Level:</div>
                    <div class="level-selector">
                        <input type="number" id="playerLevel" class="level-input" value="1" min="1" max="10" onchange="updatePlayerLevel()">
                        <span style="font-size: 0.9em; opacity: 0.9;">(affects available conditions/healing)</span>
                    </div>
                </div>
                <div class="setup-section">
                    <div class="setup-label">Magical Classes (select 1-2):</div>
                    <div class="class-grid" id="classGrid">
                        <!-- Classes will be populated here -->
                    </div>
                    <div class="class-info" id="classInfo" style="display: none;">
                        <!-- Class info will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="channel-counter">
            <div>Channel Magick Actions Available</div>
            <div class="channel-controls">
                <button class="channel-btn" onclick="adjustChannelActions(-1)">−</button>
                <div class="channel-display" id="channelCount">0</div>
                <button class="channel-btn" onclick="adjustChannelActions(1)">+</button>
            </div>
            <div style="font-size: 0.85em; margin-top: 10px; opacity: 0.9;">
                Base: 1 Component Module + 1 per Channel Action
            </div>
        </div>

        <div class="spell-builder">
            <!-- Step 1: Choose Spell Type -->
            <div class="section active" id="spellTypeSection">
                <div class="section-title">
                    <span>Step 1: Choose Spell Type</span>
                    <span class="required">*Required</span>
                    <button class="reset-btn" onclick="resetSpell()" style="display: none;" id="resetBtn">Start Over</button>
                </div>
                <div class="spell-type-selector">
                    <div class="spell-type-card" onclick="selectSpellType('attack')">
                        <div class="spell-type-icon">⚔️</div>
                        <div class="spell-type-name">Attack Spell</div>
                        <div style="font-size: 0.85em; margin-top: 5px;">Deal damage to enemies</div>
                    </div>
                    <div class="spell-type-card" onclick="selectSpellType('heal')">
                        <div class="spell-type-icon">💚</div>
                        <div class="spell-type-name">Heal Spell</div>
                        <div style="font-size: 0.85em; margin-top: 5px;">Restore health to allies</div>
                    </div>
                    <div class="spell-type-card" onclick="selectSpellType('effect')">
                        <div class="spell-type-icon">✨</div>
                        <div class="spell-type-name">Effect Spell</div>
                        <div style="font-size: 0.85em; margin-top: 5px;">Apply buffs, debuffs, or conditions</div>
                    </div>
                </div>
            </div>

            <!-- Step 2: Choose Spell Base -->
            <div class="section" id="spellBaseSection">
                <div class="section-title">
                    <span>Step 2: Choose <span id="spellTypeLabel"></span> Base</span>
                    <span class="required">*Required</span>
                </div>
                <div id="spellBaseOptions"></div>
            </div>

            <!-- Step 3: Choose Damage/Heal/Effect Type -->
            <div class="section" id="damageTypeSection">
                <div class="section-title">
                    <span>Step 3: Choose <span id="typeLabel"></span></span>
                    <span class="required">*Required</span>
                </div>
                <div id="typeOptions"></div>
            </div>

            <!-- Step 4: Component Modules -->
            <div class="section" id="componentSection">
                <div class="section-title">
                    <span>Step 4: Add Component Modules</span>
                    <span style="color: #3498db; font-weight: normal;">
                        (Available: <span id="availableModules">0</span>)
                    </span>
                </div>
                <div class="component-modules" id="componentModules"></div>
                
                <!-- Extra Buff/Debuff Selection -->
                <div id="extraBuffSection" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <h4 style="color: #2a5298; margin-bottom: 15px;">Select Extra Buff/Debuff Effects:</h4>
                    <div id="extraBuffSelections"></div>
                </div>
            </div>
        </div>

        <button class="generate-btn" onclick="showSpellNamingDialog()" id="generateBtn" style="display: none;">Generate Spell</button>

        <!-- Spell Naming Dialog -->
        <div id="spellNamingDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
                <h3 style="color: #2a5298; margin-bottom: 20px; text-align: center;">Name Your Spell</h3>
                <div style="margin-bottom: 20px;">
                    <label for="spellNameInput" style="display: block; margin-bottom: 10px; font-weight: bold; color: #555;">Spell Name:</label>
                    <input type="text" id="spellNameInput" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box;" placeholder="Enter spell name..." onkeypress="handleSpellNameKeypress(event)">
                </div>
                <div style="text-align: center;">
                    <button onclick="confirmSpellGeneration()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 25px; border: none; border-radius: 25px; font-size: 16px; font-weight: bold; cursor: pointer; margin-right: 10px;">Create Spell</button>
                    <button onclick="closeSpellNamingDialog()" style="background: #ccc; color: #333; padding: 12px 25px; border: none; border-radius: 25px; font-size: 16px; font-weight: bold; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="spellOutput" class="spell-output">
            <div class="spell-name" id="spellName"></div>
            <div class="spell-details">
                <div id="spellStats"></div>
                <div class="spell-description" id="spellDescription"></div>
            </div>
            <div class="button-group">
                <button class="save-btn" onclick="saveSpell()">Save Spell</button>
                <button class="export-btn" onclick="exportSpell()">Export as Text</button>
            </div>
        </div>

        <div class="saved-spells">
            <h2>📖 Saved Spells</h2>
            <div id="savedSpellsList"></div>
        </div>
    </div>

    <script>
        // Class definitions
        const classData = {
            minstrel: {
                name: "Minstrel",
                description: "Music, Sound, and Fortune Magick",
                damageDie: "1d8",
                healingDie: "1d8",
                damageTypes: ["sound"]
            },
            elementalist: {
                name: "Elementalist",
                description: "Fire, Ice, and Lightning Magick",
                damageDie: "1d12",
                healingDie: "1d4",
                damageTypes: ["fire", "ice", "lightning"]
            },
            priest: {
                name: "Priest",
                description: "Divine, Healing, and Light Magick",
                damageDie: "1d6",
                healingDie: "1d10",
                damageTypes: ["holy"]
            },
            occultist: {
                name: "Occultist",
                description: "Unholy, Darkness, and Curse Magick",
                damageDie: "1d10",
                healingDie: "1d6",
                damageTypes: ["shadow"]
            },
            sage: {
                name: "Sage",
                description: "Wind, Earth, Water, and Plant Magick",
                damageDie: "1d8",
                healingDie: "1d8",
                damageTypes: ["slash", "stab", "strike", "poison"]
            },
            magician: {
                name: "Magician",
                description: "Illusion, Arkane, and Transposition Magick",
                damageDie: "1d10",
                healingDie: "1d6",
                damageTypes: ["arkane"]
            },
            conjuror: {
                name: "Conjuror",
                description: "Summoning, Creation, and Rune Magick",
                damageDie: "1d8",
                healingDie: "1d8",
                damageTypes: ["poison", "acid"]
            },
            esper: {
                name: "Esper",
                description: "Psychic, Spirit, and Divination Magick",
                damageDie: "1d10",
                healingDie: "1d6",
                damageTypes: ["psychic"]
            }
        };

        // Game data structure
        const spellData = {
            attackSpells: {
                meleeStrike: { 
                    name: "Melee Spellstrike", 
                    description: "Replace a Spellcraft Attack with a Melee Attack using a weapon",
                    damage: "Weapon damage",
                    range: "Melee"
                },
                rangedStrike: { 
                    name: "Ranged Spellstrike", 
                    description: "Replace a Spellcraft Attack with a Ranged Attack using a weapon",
                    damage: "Weapon damage",
                    range: "Ranged"
                },
                bolt: { 
                    name: "Bolt", 
                    description: "Deals damage to a single target up to 12 Squares (60 feet) away",
                    damage: "2",
                    range: "12 Squares (60 ft)"
                },
                touch: { 
                    name: "Touch", 
                    description: "Deals damage to a single target within 1 Square (5 feet)",
                    damage: "3",
                    range: "1 Square (5 ft)"
                },
                cleave: { 
                    name: "Cleave", 
                    description: "Deals damage to all targets within a Cone 3 Squares (15 feet) long",
                    damage: "2",
                    range: "Cone 3 Squares",
                    area: "1/3/5 affected Squares"
                },
                bomb: { 
                    name: "Bomb", 
                    description: "Deals damage to all targets within a Cube 3 Squares (15 feet) on each side",
                    damage: "1",
                    range: "6 Squares (30 ft) away",
                    area: "3x3x3 Cube"
                },
                beam: { 
                    name: "Beam", 
                    description: "Deals damage to all targets within a Line 1 Square tall, 1 Square wide, and 6 Squares long",
                    damage: "1",
                    range: "Line 6 Squares long"
                },
                burst: { 
                    name: "Burst", 
                    description: "Deals damage to all targets within 1 Square of the caster, except the caster",
                    damage: "2",
                    range: "1 Square radius"
                }
            },
            
            effectSpells: {
                aura: {
                    name: "Aura",
                    description: "Create an effect within 2 Squares (10 feet) of you that follows you",
                    range: "2 Squares radius",
                    trigger: "Start of turn or enters"
                },
                pillar: {
                    name: "Pillar",
                    description: "Create an effect within a vertical Line 3 Squares wide, 3 Squares long, and 6 Squares tall",
                    range: "Up to 6 Squares away",
                    area: "3 sq wide x 3 sq long x 6 sq tall",
                    trigger: "Start of turn or enters"
                },
                zone: {
                    name: "Zone",
                    description: "Create an effect within a Cube 6 Squares on each side",
                    range: "Up to 6 Squares away",
                    area: "6x6x6 Cube",
                    trigger: "Start of turn or enters"
                }
            },

            healSpells: {
                healBolt: {
                    name: "Healing Bolt",
                    description: "Heals a single target up to 6 Squares (30 feet) away",
                    healing: "1",
                    range: "6 Squares (30 ft)"
                },
                healTouch: {
                    name: "Healing Touch",
                    description: "Heals a single target within your reach",
                    healing: "2",
                    range: "Touch"
                },
                healFan: {
                    name: "Healing Fan",
                    description: "Heals all targets within a Cone 3 Squares (15 feet) long",
                    healing: "1",
                    range: "Cone 3 Squares",
                    area: "1/3/5 affected Squares"
                },
                healBomb: {
                    name: "Healing Bomb",
                    description: "Heals all targets within a Cube 3 Squares on each side",
                    healing: "1",
                    range: "Up to 6 Squares away",
                    area: "3x3x3 Cube"
                },
                healBeam: {
                    name: "Healing Beam",
                    description: "Heals all targets within a Line 1 Square tall, 1 Square wide, and 6 Squares long",
                    healing: "1",
                    range: "Line 6 Squares long"
                },
                healBurst: {
                    name: "Healing Burst",
                    description: "Heals all targets within 1 Square of the caster, except the caster",
                    healing: "2",
                    range: "1 Square radius"
                }
            },

            damageTypes: {
                physical: {
                    slash: { name: "Slash", defense: "AC or Reflexes" },
                    stab: { name: "Stab", defense: "AC or Reflexes" },
                    strike: { name: "Strike", defense: "AC or Toughness" },
                    sound: { name: "Sound", defense: "AC or Toughness" }
                },
                energy: {
                    fire: { name: "Fire", defense: "AC or Reflexes" },
                    ice: { name: "Ice", defense: "AC or Toughness" },
                    lightning: { name: "Lightning", defense: "AC or Reflexes" },
                    poison: { name: "Poison", defense: "AC or Toughness" },
                    acid: { name: "Acid", defense: "AC or Reflexes" }
                },
                metaphysical: {
                    arkane: { name: "Arkane", defense: "AC or Intellect" },
                    holy: { name: "Holy", defense: "AC or Willpower" },
                    shadow: { name: "Shadow", defense: "AC or Willpower" },
                    psychic: { name: "Psychic", defense: "AC or Intellect" }
                }
            },

            healTypes: {
                hp: { name: "HP", description: "Expends one Hit Die, adding it to the roll" },
                tempHp: { name: "Temporary HP", description: "Does not require Hit Dice expenditure" },
                diseases: { name: "Diseases", description: "Remove diseases", level: 3 },
                poisons: { name: "Poisons", description: "Remove poisons", level: 3 },
                reducedStats: { name: "Reduced Max HP/Hit Dice", description: "Restore reduced maximums", level: 3 },
                lingeringInjuries: { name: "Lingering Injuries", description: "Requires Ritual, 1d10+ Healing Die", level: 5 },
                death: { name: "Death", description: "Revive (1d8+: 1 min, 1d10+: 1 hour)", level: 5 }
            },

            positiveEffects: {
                increaseAC: { name: "Increase AC", single: "+2", multi: "+1" },
                increaseDefense: { name: "Increase Attribute Defense", single: "+2", multi: "+1" },
                speedBoost: { name: "Speed Boost", single: "+4", multi: "+2" },
                attackBonus: { name: "Attack Bonus", single: "+1d6", multi: "+1d4" },
                damageBonus: { name: "Increase Damage", single: "+1d6", multi: "+1d4" },
                damageReduction: { name: "Reduce Damage Taken", single: "-1d4", multi: "-1" },
                skillBonus: { name: "Skill Check Bonus", single: "+1d4", multi: "+1d2" }
            },

            negativeEffects: {
                reduceAC: { name: "Reduce AC", single: "-2", multi: "-1", defense: "Reflexes" },
                reduceDefense: { name: "Reduce Attribute Defense", single: "-2", multi: "-1", defense: "Attribute" },
                attackPenalty: { name: "Attack Penalty", single: "-1d6", multi: "-1d4", defense: "Willpower" },
                skillPenalty: { name: "Skill Check Penalty", single: "-1d4", multi: "-1d2", defense: "Intellect" },
                forcedMovement: { name: "Forced Movement", single: "4 Squares", multi: "2 Squares", defense: "Toughness" }
            },

            conditions: {
                charmed: { name: "Charmed", defense: "Intellect", level: 1 },
                dazed: { name: "Dazed", defense: "Intellect", level: 1 },
                deafened: { name: "Deafened", defense: "Toughness", level: 1 },
                frightened: { name: "Frightened", defense: "Willpower", level: 1 },
                prone: { name: "Prone", defense: "Reflexes", level: 1 },
                sickened: { name: "Sickened", defense: "Toughness", level: 1 },
                slowed: { name: "Slowed", defense: "Willpower", level: 1 },
                blinded: { name: "Blinded", defense: "Toughness", level: 3 },
                immobilized: { name: "Immobilized", defense: "Reflexes", level: 3 },
                silenced: { name: "Silenced", defense: "Intellect", level: 3 },
                staggered: { name: "Staggered", defense: "Intellect", level: 3 },
                vulnerable: { name: "Vulnerable", defense: "Toughness", level: 5 },
                weakened: { name: "Weakened", defense: "Willpower", level: 5 },
                unconscious: { name: "Unconscious", defense: "Willpower", level: 5 }
            },

            componentModules: {
                extraDamage: { 
                    name: "Extra Damage", 
                    description: "Add an extra Damage die",
                    applicable: ["attack"]
                },
                extraHeal: { 
                    name: "Extra Healing", 
                    description: "Add an extra Healing die",
                    applicable: ["heal"]
                },
                extraBuff: { 
                    name: "Extra Buff/Debuff", 
                    description: "Adds an additional Positive or Negative effect",
                    applicable: ["all"]
                },
                additionalTarget: { 
                    name: "Additional Target", 
                    description: "Allows an additional creature to be targeted within range",
                    applicable: ["bolt", "healBolt"]
                },
                curvingBolt: { 
                    name: "Curving Bolt", 
                    description: "Your Spellcraft Attack ignores Cover",
                    applicable: ["bolt"]
                },
                recurrence: { 
                    name: "Recurrence", 
                    description: "Affected creature receives 1 die of healing/damage at start of next turn",
                    applicable: ["attack", "heal"]
                },
                concentration: { 
                    name: "Concentration", 
                    description: "Extend effects until end of next round with Concentration Action",
                    applicable: ["all"]
                },
                longBolt: { 
                    name: "Long Bolt", 
                    description: "Increase range by 3 Squares (15 feet), max 12 Squares",
                    applicable: ["bolt", "healBolt"]
                },
                wideCleave: { 
                    name: "Wide Cleave", 
                    description: "Increases Cone length by 1 Square, area becomes 1/3/5/7",
                    applicable: ["cleave"]
                },
                wideFan: { 
                    name: "Wide Fan", 
                    description: "Increases Cone length by 1 Square, area becomes 1/3/5/7",
                    applicable: ["healFan"]
                },
                bigBomb: { 
                    name: "Big Bomb/Zone", 
                    description: "Increases Cube sides by 1 Square",
                    applicable: ["bomb", "healBomb", "zone"]
                },
                bigZone: { 
                    name: "Big Zone", 
                    description: "Increases Cube sides by 1 Square",
                    applicable: ["zone"]
                },
                longBeam: { 
                    name: "Long Beam", 
                    description: "Increases Line length by 3 Squares, max 12 Squares",
                    applicable: ["beam", "healBeam"]
                },
                wideBeam: { 
                    name: "Wide Beam", 
                    description: "Increases Line width by 1 Square, max 3 Squares",
                    applicable: ["beam", "healBeam"]
                },
                radiateFurther: { 
                    name: "Radiate Further", 
                    description: "Increases area around caster by 1 Square in all directions",
                    applicable: ["burst", "healBurst", "aura"]
                },
                additionalAuraTarget: { 
                    name: "Additional Aura Target", 
                    description: "Designate another creature for aura to follow (6 Squares range)",
                    applicable: ["aura"]
                },
                changeAuraTarget: { 
                    name: "Change Aura Target", 
                    description: "Designate different creature for aura to follow",
                    applicable: ["aura"]
                },
                spellImmunity: { 
                    name: "Spell Immunity", 
                    description: "Choose whether allies or enemies ignore certain spell effects",
                    applicable: ["all"]
                },
                nonLethal: { 
                    name: "Non-lethal Damage", 
                    description: "Damage can only reduce to 0 HP and knock Unconscious",
                    applicable: ["attack"]
                }
            }
        };

        // State management
        let channelActions = 0;
        let selectedSpellType = null;
        let selectedBase = null;
        let selectedDamageType = null;
        let selectedHealType = null;
        let selectedEffectType = null;
        let selectedModules = [];
        let selectedExtraBuffs = {}; // Store extra buff/debuff selections by module instance
        let savedSpells = [];
        let playerLevel = 1;
        let selectedClasses = [];

        // Initialize the interface
        function initializeInterface() {
            renderClasses();
            updateSavedSpellsList();
            updateAvailableModules();
        }

        // Render class selection
        function renderClasses() {
            const container = document.getElementById('classGrid');
            container.innerHTML = '';
            
            for (const [key, cls] of Object.entries(classData)) {
                const div = document.createElement('div');
                div.className = 'class-option';
                div.id = `class-${key}`;
                div.onclick = function() { toggleClass(key); };
                div.textContent = cls.name;
                container.appendChild(div);
            }
        }

        // Toggle class selection
        function toggleClass(key) {
            const index = selectedClasses.indexOf(key);
            
            if (index > -1) {
                // Remove class
                selectedClasses.splice(index, 1);
            } else {
                // Add class (max 2)
                if (selectedClasses.length < 2) {
                    selectedClasses.push(key);
                } else {
                    alert('You can only select up to 2 magical classes!');
                    return;
                }
            }
            
            // Update UI
            document.querySelectorAll('.class-option').forEach(el => {
                const classKey = el.id.replace('class-', '');
                if (selectedClasses.includes(classKey)) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
            
            updateClassInfo();
            
            // If damage types are visible, update them
            if (document.getElementById('damageTypeSection').classList.contains('active') && selectedBase?.type === 'attack') {
                renderDamageTypes();
            }
        }

        // Update class info display
        function updateClassInfo() {
            const infoDiv = document.getElementById('classInfo');
            
            if (selectedClasses.length === 0) {
                infoDiv.style.display = 'none';
                return;
            }
            
            let info = '<strong>Selected Classes:</strong><br>';
            selectedClasses.forEach(key => {
                const cls = classData[key];
                info += `• ${cls.name}: ${cls.description}<br>`;
                info += `  Damage: ${cls.damageDie} | Healing: ${cls.healingDie}<br>`;
            });
            
            // Show combined damage types
            const availableTypes = getAvailableDamageTypes();
            if (availableTypes.length > 0) {
                info += '<br><strong>Available Damage Types:</strong> ';
                info += availableTypes.map(t => {
                    for (const category of Object.values(spellData.damageTypes)) {
                        if (category[t]) return category[t].name;
                    }
                    return t;
                }).join(', ');
            }
            
            infoDiv.innerHTML = info;
            infoDiv.style.display = 'block';
        }

        // Get available damage types based on selected classes
        function getAvailableDamageTypes() {
            if (selectedClasses.length === 0) {
                // No classes selected - all types available
                const allTypes = [];
                for (const category of Object.values(spellData.damageTypes)) {
                    allTypes.push(...Object.keys(category));
                }
                return allTypes;
            }
            
            const types = new Set();
            selectedClasses.forEach(key => {
                classData[key].damageTypes.forEach(type => types.add(type));
            });
            return Array.from(types);
        }

        // Get damage dice for selected classes
        function getDamageDice() {
            if (selectedClasses.length === 0) return "1d8"; // Default
            
            // Use the best damage die from selected classes
            const dice = selectedClasses.map(key => classData[key].damageDie);
            // Sort by die size (d12 > d10 > d8 > d6 > d4)
            dice.sort((a, b) => {
                const sizeA = parseInt(a.match(/d(\d+)/)[1]);
                const sizeB = parseInt(b.match(/d(\d+)/)[1]);
                return sizeB - sizeA;
            });
            return dice[0];
        }

        // Get healing dice for selected classes
        function getHealingDice() {
            if (selectedClasses.length === 0) return "1d8"; // Default
            
            // Use the best healing die from selected classes
            const dice = selectedClasses.map(key => classData[key].healingDie);
            // Sort by die size
            dice.sort((a, b) => {
                const sizeA = parseInt(a.match(/d(\d+)/)[1]);
                const sizeB = parseInt(b.match(/d(\d+)/)[1]);
                return sizeB - sizeA;
            });
            return dice[0];
        }

        // Update player level
        function updatePlayerLevel() {
            playerLevel = parseInt(document.getElementById('playerLevel').value);
            
            // If heal types or effect types are visible, re-render them
            if (document.getElementById('damageTypeSection').classList.contains('active')) {
                if (selectedBase?.type === 'heal') {
                    renderHealTypes();
                } else if (selectedBase?.type === 'effect') {
                    renderEffectTypes();
                }
            }
        }

        // Select spell type (attack/heal/effect)
        function selectSpellType(type) {
            // Clear previous selections
            document.querySelectorAll('.spell-type-card').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            selectedSpellType = type;
            selectedBase = null;
            selectedDamageType = null;
            selectedHealType = null;
            selectedEffectType = null;
            selectedModules = [];
            
            // Show reset button
            document.getElementById('resetBtn').style.display = 'inline-block';
            
            // Show spell base section and populate it
            const baseSection = document.getElementById('spellBaseSection');
            baseSection.classList.add('active');
            
            // Update label
            const typeLabels = {
                'attack': 'Attack Spell',
                'heal': 'Healing Spell',
                'effect': 'Effect Spell'
            };
            document.getElementById('spellTypeLabel').textContent = typeLabels[type];
            
            // Render appropriate spell bases
            renderSpellBases(type);
            
            // Hide other sections until base is selected
            document.getElementById('damageTypeSection').classList.remove('active');
            document.getElementById('componentSection').classList.remove('active');
            document.getElementById('generateBtn').style.display = 'none';
            document.getElementById('spellOutput').classList.remove('visible');
        }

        // Render spell bases based on type
        function renderSpellBases(type) {
            const container = document.getElementById('spellBaseOptions');
            container.innerHTML = '';
            
            let spells = {};
            let info = '';
            
            if (type === 'attack') {
                spells = spellData.attackSpells;
            } else if (type === 'heal') {
                spells = spellData.healSpells;
                info = '<div class="warning">Healing expends one of the target\'s Hit Dice. If unavailable, they take one level of Fatigue.</div>';
            } else if (type === 'effect') {
                spells = spellData.effectSpells;
                info = '<div class="info-box">Effect spells create areas that trigger when creatures start their turn in or enter the area.</div>';
            }
            
            if (info) container.innerHTML = info;
            
            const grid = document.createElement('div');
            grid.className = 'spell-base-grid';
            
            for (const [key, spell] of Object.entries(spells)) {
                const div = document.createElement('div');
                div.className = 'spell-option';
                div.onclick = function() { selectSpellBase(key); };
                
                let diceInfo = '';
                if (spell.damage) {
                    const damageDie = getDamageDice();
                    const diceCount = spell.damage;
                    diceInfo = `<div class="dice-info">${diceCount}×${damageDie}</div>`;
                }
                if (spell.healing) {
                    const healingDie = getHealingDice();
                    const diceCount = spell.healing;
                    diceInfo = `<div class="dice-info">${diceCount}×${healingDie}</div>`;
                }
                
                div.innerHTML = `
                    <div class="spell-option-title">${spell.name}</div>
                    <div class="spell-option-description">${spell.description}</div>
                    ${diceInfo}
                `;
                grid.appendChild(div);
            }
            
            container.appendChild(grid);
        }

        // Select spell base
        function selectSpellBase(key) {
            // Clear previous selections
            document.querySelectorAll('.spell-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            selectedBase = { type: selectedSpellType, key: key };
            selectedDamageType = null;
            selectedHealType = null;
            selectedEffectType = null;
            selectedModules = [];
            
            // Show appropriate type selection section
            const damageSection = document.getElementById('damageTypeSection');
            damageSection.classList.add('active');
            
            // Render appropriate type options
            if (selectedSpellType === 'attack') {
                document.getElementById('typeLabel').textContent = 'Damage Type';
                renderDamageTypes();
            } else if (selectedSpellType === 'heal') {
                document.getElementById('typeLabel').textContent = 'Healing Type';
                renderHealTypes();
            } else if (selectedSpellType === 'effect') {
                document.getElementById('typeLabel').textContent = 'Effect Type';
                renderEffectTypes();
            }
            
            // Show component section
            document.getElementById('componentSection').classList.add('active');
            renderComponentModules();
            updateModuleStates();
            updateAvailableModules();
            
            // Show generate button
            document.getElementById('generateBtn').style.display = 'block';
        }

        // Render damage types
        function renderDamageTypes() {
            const container = document.getElementById('typeOptions');
            container.innerHTML = '';
            
            const availableTypes = getAvailableDamageTypes();
            
            for (const [category, types] of Object.entries(spellData.damageTypes)) {
                const categoryDiv = document.createElement('div');
                const grid = document.createElement('div');
                grid.className = 'damage-type-grid';
                
                let hasVisibleTypes = false;
                
                for (const [key, type] of Object.entries(types)) {
                    // Skip unavailable damage types entirely
                    if (!availableTypes.includes(key)) {
                        continue;
                    }
                    
                    hasVisibleTypes = true;
                    const typeDiv = document.createElement('div');
                    typeDiv.className = 'damage-type-option';
                    typeDiv.onclick = function() { selectDamageType(key); };
                    
                    typeDiv.innerHTML = `
                        <div>${type.name}</div>
                        <div style="font-size: 0.8em; opacity: 0.8;">vs ${type.defense}</div>
                    `;
                    grid.appendChild(typeDiv);
                }
                
                // Only show category if it has visible types
                if (hasVisibleTypes) {
                    categoryDiv.innerHTML = `<div class="damage-type-category">${category}</div>`;
                    categoryDiv.appendChild(grid);
                    container.appendChild(categoryDiv);
                }
            }
            
            // Add note if classes restrict damage types
            if (selectedClasses.length > 0 && availableTypes.length < Object.keys(spellData.damageTypes.physical).length + 
                Object.keys(spellData.damageTypes.energy).length + Object.keys(spellData.damageTypes.metaphysical).length) {
                const note = document.createElement('div');
                note.className = 'info-box';
                note.style.marginTop = '15px';
                note.textContent = 'Available damage types are limited by your selected magical classes.';
                container.appendChild(note);
            }
        }

        // Render heal types
        function renderHealTypes() {
            const container = document.getElementById('typeOptions');
            container.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = 'damage-type-grid';
            
            for (const [key, type] of Object.entries(spellData.healTypes)) {
                // Skip heal types that require higher level
                if (type.level && type.level > playerLevel) {
                    continue;
                }
                
                const typeDiv = document.createElement('div');
                typeDiv.className = 'damage-type-option';
                typeDiv.onclick = function() { selectHealType(key); };
                
                let levelText = type.level ? ` (Lvl ${type.level}+)` : '';
                typeDiv.innerHTML = `
                    <div>${type.name}${levelText}</div>
                    <div style="font-size: 0.8em; opacity: 0.8;">${type.description}</div>
                `;
                grid.appendChild(typeDiv);
            }
            
            container.appendChild(grid);
        }

        // Render effect types
        function renderEffectTypes() {
            const container = document.getElementById('typeOptions');
            container.innerHTML = '';
            
            // Positive Effects
            const posDiv = document.createElement('div');
            posDiv.innerHTML = '<div class="damage-type-category">Positive Effects (Allies)</div>';
            const posGrid = document.createElement('div');
            posGrid.className = 'damage-type-grid';
            
            for (const [key, effect] of Object.entries(spellData.positiveEffects)) {
                const effectDiv = document.createElement('div');
                effectDiv.className = 'damage-type-option';
                effectDiv.onclick = function() { selectEffectType('positive', key); };
                effectDiv.innerHTML = `
                    <div>${effect.name}</div>
                    <div style="font-size: 0.8em;">Single: ${effect.single} | Multi: ${effect.multi}</div>
                `;
                posGrid.appendChild(effectDiv);
            }
            posDiv.appendChild(posGrid);
            container.appendChild(posDiv);
            
            // Negative Effects
            const negDiv = document.createElement('div');
            negDiv.innerHTML = '<div class="damage-type-category">Negative Effects (Enemies)</div>';
            const negGrid = document.createElement('div');
            negGrid.className = 'damage-type-grid';
            
            for (const [key, effect] of Object.entries(spellData.negativeEffects)) {
                const effectDiv = document.createElement('div');
                effectDiv.className = 'damage-type-option';
                effectDiv.onclick = function() { selectEffectType('negative', key); };
                effectDiv.innerHTML = `
                    <div>${effect.name}</div>
                    <div style="font-size: 0.8em;">Single: ${effect.single} | Multi: ${effect.multi} | vs ${effect.defense}</div>
                `;
                negGrid.appendChild(effectDiv);
            }
            negDiv.appendChild(negGrid);
            container.appendChild(negDiv);
            
            // Conditions
            const condDiv = document.createElement('div');
            const condGrid = document.createElement('div');
            condGrid.className = 'damage-type-grid';
            
            let hasVisibleConditions = false;
            
            for (const [key, condition] of Object.entries(spellData.conditions)) {
                // Skip conditions that require higher level
                if (condition.level > playerLevel) {
                    continue;
                }
                
                hasVisibleConditions = true;
                const conditionDiv = document.createElement('div');
                conditionDiv.className = 'damage-type-option';
                conditionDiv.onclick = function() { selectEffectType('condition', key); };
                
                let levelText = condition.level > 1 ? ` (Lvl ${condition.level}+)` : '';
                conditionDiv.innerHTML = `
                    <div>${condition.name}${levelText}</div>
                    <div style="font-size: 0.8em;">vs ${condition.defense}</div>
                `;
                condGrid.appendChild(conditionDiv);
            }
            
            // Only show conditions section if there are visible conditions
            if (hasVisibleConditions) {
                condDiv.innerHTML = '<div class="damage-type-category">Conditions</div>';
                condDiv.appendChild(condGrid);
                container.appendChild(condDiv);
            }
        }

        // Update extra buff/debuff selection section
        function updateExtraBuffSection() {
            const extraBuffCount = selectedModules.filter(module => module === 'extraBuff').length;
            const section = document.getElementById('extraBuffSection');
            const container = document.getElementById('extraBuffSelections');
            
            if (extraBuffCount === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            container.innerHTML = '';
            
            // Create selection interface for each extraBuff module
            for (let i = 0; i < extraBuffCount; i++) {
                const buffDiv = document.createElement('div');
                buffDiv.style.marginBottom = '20px';
                buffDiv.style.padding = '15px';
                buffDiv.style.background = '#f8f9ff';
                buffDiv.style.borderRadius = '10px';
                buffDiv.style.border = '2px solid #ddd';
                
                buffDiv.innerHTML = `
                    <h5 style="color: #2a5298; margin-bottom: 10px;">Extra Effect #${i + 1}:</h5>
                    <div id="extraBuffOptions_${i}"></div>
                `;
                
                container.appendChild(buffDiv);
                renderExtraBuffOptions(i);
            }
        }

        // Render effect options for extra buff/debuff (same as effect spell types)
        function renderExtraBuffOptions(index) {
            const container = document.getElementById(`extraBuffOptions_${index}`);
            container.innerHTML = '';
            
            // Positive Effects
            const posDiv = document.createElement('div');
            posDiv.innerHTML = '<div class="damage-type-category">Positive Effects (Allies)</div>';
            const posGrid = document.createElement('div');
            posGrid.className = 'damage-type-grid';
            
            for (const [key, effect] of Object.entries(spellData.positiveEffects)) {
                const effectDiv = document.createElement('div');
                effectDiv.className = 'damage-type-option';
                effectDiv.onclick = function() { selectExtraBuff(index, 'positive', key); };
                effectDiv.innerHTML = `
                    <div>${effect.name}</div>
                    <div style="font-size: 0.8em;">Single: ${effect.single} | Multi: ${effect.multi}</div>
                `;
                posGrid.appendChild(effectDiv);
            }
            posDiv.appendChild(posGrid);
            container.appendChild(posDiv);
            
            // Negative Effects
            const negDiv = document.createElement('div');
            negDiv.innerHTML = '<div class="damage-type-category">Negative Effects (Enemies)</div>';
            const negGrid = document.createElement('div');
            negGrid.className = 'damage-type-grid';
            
            for (const [key, effect] of Object.entries(spellData.negativeEffects)) {
                const effectDiv = document.createElement('div');
                effectDiv.className = 'damage-type-option';
                effectDiv.onclick = function() { selectExtraBuff(index, 'negative', key); };
                effectDiv.innerHTML = `
                    <div>${effect.name}</div>
                    <div style="font-size: 0.8em;">Single: ${effect.single} | Multi: ${effect.multi} | vs ${effect.defense}</div>
                `;
                negGrid.appendChild(effectDiv);
            }
            negDiv.appendChild(negGrid);
            container.appendChild(negDiv);
            
            // Conditions
            const condDiv = document.createElement('div');
            const condGrid = document.createElement('div');
            condGrid.className = 'damage-type-grid';
            
            let hasVisibleConditions = false;
            
            for (const [key, condition] of Object.entries(spellData.conditions)) {
                // Skip conditions that require higher level
                if (condition.level > playerLevel) {
                    continue;
                }
                
                hasVisibleConditions = true;
                const conditionDiv = document.createElement('div');
                conditionDiv.className = 'damage-type-option';
                conditionDiv.onclick = function() { selectExtraBuff(index, 'condition', key); };
                
                let levelText = condition.level > 1 ? ` (Lvl ${condition.level}+)` : '';
                conditionDiv.innerHTML = `
                    <div>${condition.name}${levelText}</div>
                    <div style="font-size: 0.8em;">vs ${condition.defense}</div>
                `;
                condGrid.appendChild(conditionDiv);
            }
            
            // Only show conditions section if there are visible conditions
            if (hasVisibleConditions) {
                condDiv.innerHTML = '<div class="damage-type-category">Conditions</div>';
                condDiv.appendChild(condGrid);
                container.appendChild(condDiv);
            }
            
            // Update selections if any exist
            updateExtraBuffSelections(index);
        }

        // Select extra buff/debuff
        function selectExtraBuff(index, category, key) {
            const container = document.getElementById(`extraBuffOptions_${index}`);
            container.querySelectorAll('.damage-type-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            selectedExtraBuffs[`extraBuff_${index}`] = { category, key };
        }

        // Update extra buff selections display
        function updateExtraBuffSelections(index) {
            const selection = selectedExtraBuffs[`extraBuff_${index}`];
            if (!selection) return;
            
            const container = document.getElementById(`extraBuffOptions_${index}`);
            container.querySelectorAll('.damage-type-option').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Find and select the appropriate option
            container.querySelectorAll('.damage-type-option').forEach(el => {
                const onclick = el.getAttribute('onclick');
                if (onclick && onclick.includes(`'${selection.category}', '${selection.key}'`)) {
                    el.classList.add('selected');
                }
            });
        }
        function renderComponentModules() {
            const container = document.getElementById('componentModules');
            container.innerHTML = '';
            
            for (const [key, module] of Object.entries(spellData.componentModules)) {
                // Skip non-applicable modules entirely
                if (!isModuleApplicable(module)) {
                    continue;
                }
                
                const div = document.createElement('div');
                div.className = 'component-module';
                div.id = `module-${key}`;
                div.onclick = function() { toggleModule(key); };
                div.innerHTML = `
                    <div class="component-module-title">${module.name}</div>
                    <div class="component-module-description">${module.description}</div>
                `;
                container.appendChild(div);
            }
        }

        // Select damage type
        function selectDamageType(key) {
            document.querySelectorAll('#typeOptions .damage-type-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            selectedDamageType = key;
        }

        // Select heal type
        function selectHealType(key) {
            document.querySelectorAll('#typeOptions .damage-type-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            selectedHealType = key;
        }

        // Select effect type
        function selectEffectType(category, key) {
            document.querySelectorAll('#typeOptions .damage-type-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            selectedEffectType = { category, key };
        }

        // Toggle module selection
        function toggleModule(key) {
            const module = spellData.componentModules[key];
            if (!isModuleApplicable(module)) return;
            
            const index = selectedModules.indexOf(key);
            if (index > -1) {
                selectedModules.splice(index, 1);
                // Remove associated extra buff selections
                if (key === 'extraBuff') {
                    delete selectedExtraBuffs[`extraBuff_${index}`];
                }
            } else {
                // Allow 1 base module + 1 per channel action
                const maxModules = channelActions + 1;
                if (selectedModules.length < maxModules) {
                    selectedModules.push(key);
                }
            }
            
            updateModuleStates();
            updateAvailableModules();
            updateExtraBuffSection();
        }

        // Check if module is applicable
        function isModuleApplicable(module) {
            if (!selectedBase) return false;
            if (module.applicable.includes('all')) return true;
            if (module.applicable.includes(selectedBase.type)) return true;
            if (module.applicable.includes(selectedBase.key)) return true;
            return false;
        }

        // Update module states
        function updateModuleStates() {
            document.querySelectorAll('.component-module').forEach(el => {
                const key = el.id.replace('module-', '');
                
                el.classList.remove('selected', 'disabled');
                
                if (selectedModules.includes(key)) {
                    el.classList.add('selected');
                } else if (selectedModules.length >= (channelActions + 1)) {
                    el.classList.add('disabled');
                }
            });
        }

        // Adjust channel actions
        function adjustChannelActions(change) {
            channelActions = Math.max(0, Math.min(10, channelActions + change));
            document.getElementById('channelCount').textContent = channelActions;
            updateAvailableModules();
            
            // Remove excess modules if needed (max is channelActions + 1)
            const maxModules = channelActions + 1;
            if (selectedModules.length > maxModules) {
                selectedModules = selectedModules.slice(0, maxModules);
                updateModuleStates();
            }
        }

        // Update available modules display
        function updateAvailableModules() {
            const maxModules = channelActions + 1;
            const available = maxModules - selectedModules.length;
            document.getElementById('availableModules').textContent = available;
        }

        // Reset spell
        function resetSpell() {
            selectedSpellType = null;
            selectedBase = null;
            selectedDamageType = null;
            selectedHealType = null;
            selectedEffectType = null;
            selectedModules = [];
            selectedExtraBuffs = {};
            
            // Reset UI
            document.querySelectorAll('.spell-type-card').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.section').forEach(el => el.classList.remove('active'));
            document.getElementById('spellTypeSection').classList.add('active');
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('generateBtn').style.display = 'none';
            document.getElementById('spellOutput').classList.remove('visible');
            document.getElementById('extraBuffSection').style.display = 'none';
            
            updateAvailableModules();
        }

        // Handle keyboard events in spell name input
        function handleSpellNameKeypress(event) {
            if (event.key === 'Enter') {
                confirmSpellGeneration();
            } else if (event.key === 'Escape') {
                closeSpellNamingDialog();
            }
        }

        // Show spell naming dialog
        function showSpellNamingDialog() {
            // First validate the spell is ready
            if (!selectedBase) {
                alert('Please select a spell base!');
                return;
            }
            
            if (selectedBase.type === 'attack' && !selectedDamageType) {
                alert('Please select a damage type!');
                return;
            }
            
            if (selectedBase.type === 'heal' && !selectedHealType) {
                alert('Please select a healing type!');
                return;
            }
            
            if (selectedBase.type === 'effect' && !selectedEffectType) {
                alert('Please select an effect type!');
                return;
            }
            
            // Check if all extra buff/debuff selections are made
            const extraBuffCount = selectedModules.filter(module => module === 'extraBuff').length;
            const selectedExtraBuffCount = Object.keys(selectedExtraBuffs).length;
            
            if (extraBuffCount > selectedExtraBuffCount) {
                alert('Please select all extra buff/debuff effects!');
                return;
            }
            
            // Generate suggested name
            const tempSpell = compileSpell();
            const suggestedName = tempSpell.name;
            
            // Show dialog with suggested name
            document.getElementById('spellNameInput').value = suggestedName;
            document.getElementById('spellNamingDialog').style.display = 'block';
            
            // Focus and select the text for easy editing
            const input = document.getElementById('spellNameInput');
            input.focus();
            input.select();
        }

        // Close spell naming dialog
        function closeSpellNamingDialog() {
            document.getElementById('spellNamingDialog').style.display = 'none';
        }

        // Confirm spell generation with custom name
        function confirmSpellGeneration() {
            const customName = document.getElementById('spellNameInput').value.trim();
            
            if (!customName) {
                alert('Please enter a name for your spell!');
                return;
            }
            
            const spell = compileSpell();
            spell.name = customName; // Override with custom name
            spell.customName = customName; // Store custom name separately
            
            closeSpellNamingDialog();
            displaySpell(spell);
            
            // Store for saving
            window.currentSpell = spell;
        }

        // Generate spell (old function - now just calls the dialog)
        function generateSpell() {
            showSpellNamingDialog();
        }

        // Compile spell data
        function compileSpell() {
            let spell = {
                base: selectedBase,
                modules: selectedModules,
                extraBuffs: selectedExtraBuffs,
                channelActions: channelActions,
                classes: [...selectedClasses],
                level: playerLevel
            };
            
            // Get base spell data
            let baseData;
            if (selectedBase.type === 'attack') {
                baseData = spellData.attackSpells[selectedBase.key];
                spell.damageType = selectedDamageType;
            } else if (selectedBase.type === 'heal') {
                baseData = spellData.healSpells[selectedBase.key];
                spell.healType = selectedHealType;
            } else {
                baseData = spellData.effectSpells[selectedBase.key];
                spell.effectType = selectedEffectType;
            }
            
            spell.name = generateSpellName(spell, baseData);
            spell.description = generateSpellDescription(spell, baseData);
            spell.stats = generateSpellStats(spell, baseData);
            
            return spell;
        }

        // Generate spell name
        function generateSpellName(spell, baseData) {
            let name = baseData.name;
            
            // Add type prefix
            if (spell.damageType) {
                const damageData = findDamageType(spell.damageType);
                name = damageData.name + " " + name;
            } else if (spell.healType) {
                const healData = spellData.healTypes[spell.healType];
                if (spell.healType !== 'hp') {
                    name = healData.name + " " + name;
                }
            } else if (spell.effectType) {
                const effectData = getEffectData(spell.effectType);
                name = effectData.name + " " + name;
            }
            
            // Add modifiers for modules
            if (spell.modules.includes('concentration')) {
                name = "Sustained " + name;
            }
            if (spell.modules.includes('extraDamage')) {
                name = "Empowered " + name;
            }
            
            return name;
        }

        // Generate spell description
        function generateSpellDescription(spell, baseData) {
            let description = baseData.description;
            
            // Add module effects
            spell.modules.forEach(moduleKey => {
                const module = spellData.componentModules[moduleKey];
                if (moduleKey === 'extraBuff') {
                    description += ` [${module.name}: ${module.description}]`;
                } else {
                    description += ` [${module.name}: ${module.description}]`;
                }
            });
            
            // Add extra buff/debuff details
            Object.values(spell.extraBuffs || {}).forEach((extraBuff, index) => {
                const effectData = getEffectData(extraBuff);
                description += ` [Extra Effect ${index + 1}: ${effectData.name}]`;
            });
            
            return description;
        }

        // Generate spell stats
        function generateSpellStats(spell, baseData) {
            let stats = [];
            
            // Character classes
            if (spell.classes.length > 0) {
                const classNames = spell.classes.map(c => classData[c].name).join(" / ");
                stats.push({ label: "Class", value: classNames });
            }
            
            // Base type
            stats.push({ label: "Type", value: spell.base.type.charAt(0).toUpperCase() + spell.base.type.slice(1) });
            
            // Range
            if (baseData.range) {
                stats.push({ label: "Range", value: baseData.range });
            }
            
            // Area (if applicable)
            if (baseData.area) {
                stats.push({ label: "Area", value: baseData.area });
            }
            
            // Damage/Healing with proper dice
            if (baseData.damage) {
                const damageDie = getDamageDice();
                let damage = baseData.damage + "×" + damageDie;
                if (spell.modules.includes('extraDamage')) {
                    damage += " + 1×" + damageDie;
                }
                stats.push({ label: "Damage", value: damage });
            } else if (baseData.healing) {
                const healingDie = getHealingDice();
                let healing = baseData.healing + "×" + healingDie;
                if (spell.modules.includes('extraHeal')) {
                    healing += " + 1×" + healingDie;
                }
                stats.push({ label: "Healing", value: healing });
            }
            
            // Damage type defense
            if (spell.damageType) {
                const damageData = findDamageType(spell.damageType);
                stats.push({ label: "Defense", value: damageData.defense });
            }
            
            // Effect details
            if (spell.effectType) {
                const effectData = getEffectData(spell.effectType);
                stats.push({ label: "Effect Type", value: effectData.name });
                if (effectData.defense) {
                    stats.push({ label: "Defense", value: effectData.defense });
                }
                if (effectData.single) {
                    stats.push({ label: "Effect", value: `Single Target: ${effectData.single}, Multi Target: ${effectData.multi}` });
                }
            }
            
            // Duration
            let duration = "Until end of next turn";
            if (spell.modules.includes('concentration')) {
                duration = "Concentration";
            }
            stats.push({ label: "Duration", value: duration });
            
            // Channel Actions
            stats.push({ label: "Channel Actions", value: channelActions });
            
            return stats;
        }

        // Find damage type data
        function findDamageType(key) {
            for (const category of Object.values(spellData.damageTypes)) {
                if (category[key]) {
                    return category[key];
                }
            }
            return null;
        }

        // Get effect data
        function getEffectData(effectType) {
            if (effectType.category === 'positive') {
                return spellData.positiveEffects[effectType.key];
            } else if (effectType.category === 'negative') {
                return spellData.negativeEffects[effectType.key];
            } else {
                return spellData.conditions[effectType.key];
            }
        }

        // Display spell
        function displaySpell(spell) {
            document.getElementById('spellName').textContent = spell.name;
            
            let statsHtml = '';
            spell.stats.forEach(stat => {
                statsHtml += `
                    <div class="detail-row">
                        <span class="detail-label">${stat.label}:</span>
                        <span class="detail-value">${stat.value}</span>
                    </div>
                `;
            });
            document.getElementById('spellStats').innerHTML = statsHtml;
            
            document.getElementById('spellDescription').textContent = spell.description;
            
            const output = document.getElementById('spellOutput');
            output.classList.add('visible');
        }

        // Save spell
        function saveSpell() {
            if (!window.currentSpell) {
                alert('Generate a spell first!');
                return;
            }
            
            savedSpells.push({...window.currentSpell, id: Date.now()});
            updateSavedSpellsList();
            alert(`${window.currentSpell.name} has been saved!`);
        }

        // Update saved spells list
        function updateSavedSpellsList() {
            const container = document.getElementById('savedSpellsList');
            
            if (savedSpells.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999;">No saved spells yet!</p>';
                return;
            }
            
            container.innerHTML = savedSpells.map(spell => {
                const classText = spell.classes.length > 0 ? 
                    ` (${spell.classes.map(c => classData[c]?.name || c).join('/')})` : '';
                
                return `
                    <div class="spell-card" onclick="loadSpell(${spell.id})">
                        <button class="delete-btn" onclick="deleteSpell(event, ${spell.id})">×</button>
                        <div style="font-weight: bold; font-size: 1.2em; color: #2a5298; margin-bottom: 8px;">
                            ${spell.name}${classText}
                        </div>
                        <div style="font-size: 0.95em;">${spell.description}</div>
                        <div style="margin-top: 8px; font-size: 0.85em; color: #666;">
                            Channel Actions: ${spell.channelActions} | Level: ${spell.level}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Load spell
        function loadSpell(id) {
            const spell = savedSpells.find(s => s.id === id);
            if (!spell) return;
            
            // Reset first
            resetSpell();
            
            // Set character setup
            channelActions = spell.channelActions;
            document.getElementById('channelCount').textContent = channelActions;
            
            if (spell.level) {
                playerLevel = spell.level;
                document.getElementById('playerLevel').value = playerLevel;
            }
            
            if (spell.classes) {
                selectedClasses = [...spell.classes];
                document.querySelectorAll('.class-option').forEach(el => {
                    const classKey = el.id.replace('class-', '');
                    if (selectedClasses.includes(classKey)) {
                        el.classList.add('selected');
                    }
                });
                updateClassInfo();
            }
            
            // Reselect spell type
            selectSpellType(spell.base.type);
            
            // Wait a moment for UI to update, then continue
            setTimeout(function() {
                // Select base
                selectedBase = spell.base;
                
                // Select types
                if (spell.damageType) {
                    selectedDamageType = spell.damageType;
                }
                if (spell.healType) {
                    selectedHealType = spell.healType;
                }
                if (spell.effectType) {
                    selectedEffectType = spell.effectType;
                }
                
                // Select modules
                selectedModules = [...spell.modules];
                
                // Restore extra buff selections
                if (spell.extraBuffs) {
                    selectedExtraBuffs = {...spell.extraBuffs};
                }
                
                // Update UI to reflect loaded spell
                updateModuleStates();
                updateAvailableModules();
                updateExtraBuffSection();
                
                // Display
                displaySpell(spell);
            }, 100);
        }

        // Delete spell
        function deleteSpell(event, id) {
            event.stopPropagation();
            if (confirm('Delete this spell?')) {
                savedSpells = savedSpells.filter(s => s.id !== id);
                updateSavedSpellsList();
            }
        }

        // Export spell
        function exportSpell() {
            if (!window.currentSpell) {
                alert('Generate a spell first!');
                return;
            }
            
            const spell = window.currentSpell;
            let text = `===== ${spell.name} =====\n\n`;
            
            if (spell.classes.length > 0) {
                text += `Classes: ${spell.classes.map(c => classData[c].name).join(', ')}\n`;
                text += `Level: ${spell.level}\n\n`;
            }
            
            text += `${spell.description}\n\n`;
            text += `--- Stats ---\n`;
            spell.stats.forEach(stat => {
                text += `${stat.label}: ${stat.value}\n`;
            });
            
            // Create download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${spell.name.replace(/\s+/g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize on load
        initializeInterface();
    </script>
</body>
</html>
